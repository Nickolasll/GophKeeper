# 001. Использование библиотеки CLI
### Контекст
Для клиентского приложения нужно реализовать CLI интерфейс.
### Решение
Будем использовать библиотеку CLI для ускорения работы.
### Последствия
Мы реализуем клиент с использованием внешней зависимости для ускорения разработки.


# 002. Использование библиотеки chi
### Контекст
Для серверного приложения нужно реализовать RESTful API.
### Решение
Будем использовать библиотеку chi для ускорения работы.
### Последствия
Мы реализуем сервер с использованием внешней зависимости для ускорения разработки.


# 003. Использование библиотеки resty
### Контекст
Клиентскому приложению необходимо обмениваться данными с сервером по HTTP.
### Решение
Будем использовать библиотеку resty для ускорения работы.
### Последствия
Мы реализуем клиент-серверное взаимодействие с использованием внешней зависимости для ускорения разработки.


# 004. Передача по сети данных в незашифрованном виде
### Контекст
Мы предоставим API от серверной части для самописных клиентов, при использовании API необходимо получать ответы с данными в незашифрованном виде.
### Решение
Будем использовать Transport Layer Security (TLS) для того, чтобы защитить сам канал передачи данных.
### Последствия
Мы предоставляем нормальный API, но увеличиваем риски потерять пользовательские данные при передаче.


# 005. Не реализуем пакетную загрузку данных на сервер
### Контекст
Если будет несколько клиентов, которые хранят оффлайн незакоммиченные данные, то обязательно возникнут конфликты.
### Решение
При каждом изменении данных клиент сразу шлет на сервер данные.
### Последствия
Если пропадет интернет, то локально измененные данные не будут обновлены.


# 006. Клиенту необходимо иметь публичный ключ для верификации JWT
### Контекст
Для того чтобы верифицировать подлинность и срок действия JWT, а также извлекать из него идентификатор пользователя, клиенту необходим публичный ключ, который может изменяться вместе с приватным ключем на сервере. Зашить в бинарник клиента его не получится, поэтому лучше запрашивать с сервера.
### Решение
В случае обновления приватного и публичного ключа на сервере, клиент просто перезапросит ключи и попросит переавторизоваться.
### Последствия
Можно без рисков обновлять ключи на сервере, однако у клиента теперь есть необходимость перезапрашивать ключ в случае неудачи. 


# 007. Сервер и клиент имеют свои секретные ключи для шифрования данных
### Контекст
На клиенте и на сервере данные должны храниться в зашифрованном виде.
### Решение
Клиент и сервер сами на своей стороне шифруют данные и не обмениваются ключами (кроме авторизации).
### Последствия
Если изменится секрет на клиенте или на сервере есть риск больше не расшифровать данные.


# 008. Все данные всех пользователей на клиенте хранятся в одном файле
### Контекст
На клиенте данные должны храниться в зашифрованном виде и нужно скрыть сколько у какого пользователя хранится определенных данных.
### Решение
Все данные всех пользователей на клиенте хранятся в одном файле.
### Последствия
Потеря одного файла ведет к риску потерять локальные данные.


# 009. На сервере структура данных остается открытой, но значения шифруются
### Контекст
Мы должны хранить все данные пользователей в зашифрованном виде, но нужно оставить возможность для простой миграции данных.
### Решение
Структура данных остается открытой, шифруются только значения.
### Последствия
Если злоумышленник получит доступ к бд на сервере, ему будет проще найти интересующие его зашифрованные данные.


# 010. На клиенте данные шифруются полностью, вместе со структурой
### Контекст
Мы должны хранить все данные пользователей в зашифрованном виде, но вероятность утечки пользовательского файла крайне выше, чем на сервере.
### Решение
Данные шифруются целиком на стороне клиента логикой репозитория.
### Последствия
Если злоумышленник получит доступ к файлу с пользовательскими данными, он сможет выделить только коллекции данных и уникальные идентификаторы.


# 011. Необходимо кодогенерировать API
### Контекст
Для предоставления API пользователям, необходимо поддерживать его всегда в катуальном состоянии.
### Решение
Чтобы экономить время, лучше использовать генератор API, например `https://github.com/swaggo/swag`.
### Последствия
Документация API будет всегда актуальна.


# 012. Использование bboltdb для клиента
### Контекст
Для хранения не хочется самим реализовывать запись в файл.
### Решение
Чтобы не реализовать самостоятельно запись файлы, можно использовать embed базу `bboltdb`.
### Последствия
Нужно записывать в файл сразу зашифрованные данные, но не шифровать файл. Это может раскрыть сколько ресурсов есть у пользователя и их идентификаторы на стороне сервера.


# 013. Использование одного запроса на синхронизацию всего контента
### Контекст
Чтобы клиент синхронизировал данные с сервером можно использовать несколько асинхронных ресурсов для получения контента, либо один большой.
### Решение
Использовать один запрос на получение всего контента, но с использованием сжатия.
### Последствия
В случае сбоя сети необходимо будет делать большой запрос повторно.


# 014. Использование фасадов (оъединение нескольких сценариев использования в один)
### Контекст
При большом количестве CRUD сценариев, их становится слишком много и в них становится тяжело ориентироваться.
### Решение
Использовать фасад и объединять несколько сценариев в один с возможностью вызвать вложенный сценарий.
### Последствия
Дополнительный слой абстракции немного увеличит количество сущностей, но упростит вызов бизнес логики при использовании автодописывания.


# 015. Параллельное чтение данных из разных репозиториев в пределах одного сценария
### Контекст
Клиент для синхронизации запрашивает сразу все данные пользователя, которые можно достать из 4х разных инстансов репозитория, можно использовать параллелизм, чтобы ускорить обработку такого запроса
### Решение
Использовать горутины и пул соединений, чтобы ускорить чтение данных в данном сценарии.
### Последствия
В худшем случае данные будут получены за время последовательной обработки, но ожидается уменьшение времени исполнения запроса.


# 016. Использование паттерна Unit Of Work для обеспечения транзакционной целостности сохранения сущностей разных типов в пределах одного сценария
### Контекст
Клиент для синхронизации запрашивает сразу все данные пользователя, и их нужно сохранить в пределах одной транзакции.
### Решение
Использовать паттерн Unit Of Work, чтобы сделать операционный слой независимым от инфраструктурного, а также независимым от выбора базы данных.
### Последствия
В случае необходимости можно будет легко заменить реализацию репозитория, необходимо только сохранить сигнатуры интерфейсов при имплементации.
