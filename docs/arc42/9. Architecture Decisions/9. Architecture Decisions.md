# 001. Использование библиотеки CLI
### Контекст
Для клиентского приложения нужно реализовать CLI интерфейс
### Решение
Будем использовать библиотеку CLI для ускорения работы
### Последствия
Мы реализуем клиент с использованием внешней зависимости для ускорения разработки


# 002. Использование библиотеки chi
### Контекст
Для серверного приложения нужно реализовать RESTful API
### Решение
Будем использовать библиотеку chi для ускорения работы
### Последствия
Мы реализуем сервер с использованием внешней зависимости для ускорения разработки


# 003. Использование библиотеки resty
### Контекст
Клиентскому приложению необходимо обмениваться данными с сервером по HTTP
### Решение
Будем использовать библиотеку resty для ускорения работы
### Последствия
Мы реализуем клиент-серверное взаимодействие с использованием внешней зависимости для ускорения разработки


# 004. Передача по сети данных в незашифрованном виде
### Контекст
Мы предоставим API от серверной части для самописных клиентов, при использовании API необходимо получать ответы с данными в незашифрованном виде
### Решение
Будем использовать Transport Layer Security (TLS) для того, чтобы защитить сам канал передачи данных
### Последствия
Мы предоставляем нормальный API, но увеличиваем риски потерять пользовательские данные при передаче


# 005. Не реализуем пакетную загрузку данных на сервер
### Контекст
Если будет несколько клиентов, которые хранят оффлайн незакоммиченные данные, то обязательно возникнут конфликты
### Решение
При каждом изменении данных клиент сразу шлет на сервер данные
### Последствия
Если пропадет интернет, то локально измененные данные не будут обновлены


# 006. Сервер и клиент имеют свои секретные ключи для шифрования данных
### Контекст
На клиенте и на сервере данные должны храниться в зашифрованном виде
### Решение
Клиент и сервер сами на своей стороне шифруют данные и не обмениваются ключами (кроме авторизации)
### Последствия
Если изменится секрет на клиенте или на сервере есть риск больше не расшифровать данные


# 007. Все данные всех пользователей на клиенте хранятся в одном файле
### Контекст
На клиенте данные должны храниться в зашифрованном виде и нужно скрыть сколько у какого пользователя хранится определенных данных
### Решение
Все данные всех пользователей на клиенте хранятся в одном файле
### Последствия
Потеря одного файла ведет к риску потерять локальные данные

# 008. На сервере структура данных остается открытой, но значения шифруются
### Контекст
Мы должны хранить все данные пользователей в зашифрованном виде, но нужно оставить возможность для простой миграции данных
### Решение
Структура данных остается открытой, шифруются только значения
### Последствия
Если злоумышленник получит доступ к бд на сервере, ему будет проще найти интересующие его зашифрованные данные

# 009. На клиенте данные шифруются полностью, вместе со структурой
### Контекст
Мы должны хранить все данные пользователей в зашифрованном виде, но вероятность утечки пользовательского файла крайне выше, чем на сервере.
### Решение
Данные шифруются целиком на стороне клиента логикой репозитория
### Последствия
Если злоумышленник получит доступ к файлу с пользовательскими данными, он сможет выделить только коллекции данных и уникальные идентификаторы


# 010. Необходимо кодогенерировать API
### Контекст
Для предоставления API пользователям, необходимо поддерживать его всегда в катуальном состоянии
### Решение
Чтобы экономить время, лучше использовать генератор API, например `https://github.com/swaggo/swag`
### Последствия
Документация API будет всегда актуальна


# 011. Использование bboltdb для клиента
### Контекст
Для хранения не хочется самим реализовывать запись в файл
### Решение
Чтобы не реализовать самостоятельно запись файлы, можно использовать embed базу `bboltdb`
### Последствия
Нужно записывать в файл сразу зашифрованные данные, но не шифровать файл. Это может раскрыть сколько ресурсов есть у пользователя и их идентификаторы на стороне сервера.

# 012. Использование одного запроса на синхронизацию всего контента
### Контекст
Чтобы клиент синхронизировал данные с сервером можно использовать несколько асинхронных ресурсов для получения контента, либо один большой
### Решение
Использовать один запрос на получение всего контента, но с использованием сжатия
### Последствия
В случае сбоя сети необходимо будет делать большой запрос повторно

# 013. Использование фасадов (оъединение нескольких сценариев использования в один)
### Контекст
При большом количестве CRUD сценариев, их становится слишком много и в них становится тяжело ориентироваться
### Решение
Использовать фасад и объединять несколько сценариев в один с возможностью вызвать вложенный сценарий
### Последствия
Дополнительный слой абстракции немного увеличит количество сущностей, но упростит вызов бизнес логики при использовании автодописывания
