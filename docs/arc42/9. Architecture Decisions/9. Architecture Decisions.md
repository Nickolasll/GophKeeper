# 001. Использование библиотеки CLI
### Контекст
Для клиентского приложения нужно реализовать CLI интерфейс.
### Решение
Будем использовать библиотеку CLI для ускорения работы.
### Последствия
Мы реализуем клиент с использованием внешней зависимости для ускорения разработки.


# 002. Использование библиотеки chi
### Контекст
Для серверного приложения нужно реализовать RESTful API.
### Решение
Будем использовать библиотеку chi для ускорения работы.
### Последствия
Мы реализуем сервер с использованием внешней зависимости для ускорения разработки.


# 003. Использование библиотеки resty
### Контекст
Клиентскому приложению необходимо обмениваться данными с сервером по HTTP.
### Решение
Будем использовать библиотеку resty для ускорения работы. Можно было бы генерировать клиент из openapi, но хотелось самостоятельно реализовать решение.
### Последствия
Мы реализуем клиент-серверное взаимодействие с использованием внешней зависимости для ускорения разработки.


# 004. Логгирование в формате JSON
### Контекст
Каждый запрос к серверу должен мониториться в `middleware`, при этом должно быть вычислено время выполнения запроса. Также необходимо мониторить ошибки на стороне сервера и в удобном формате получать отчеты об ошибках от клиента.
### Решение
Форматировать логи с использованием `JSON`, так как его удобно парсить. На стороне клиента нужно сохранять логи с ошибками в отдельный файл. 
### Последствия
Получаем от клиента и сервера логи в удобном формате.


# 005. Передача по сети данных в незашифрованном виде
### Контекст
Данные от клиентов необходимо защитить при передаче, но не хочется изобретать свой способ защиты.
Хочется предоставлять API от серверной части для самописных клиентов, при использовании API необходимо получать ответы с данными в незашифрованном виде.
### Решение
Будем использовать Transport Layer Security (TLS) для того, чтобы защитить сам канал передачи данных.
### Последствия
Мы предоставляем нормальный API, но повышаем риски потерять пользовательские данные при передаче.


# 006. Сервер и клиент имеют свои секретные ключи для шифрования данных
### Контекст
На клиенте и на сервере данные должны храниться в зашифрованном виде. Но процесс шифрования данных на клиенте и сервере не должен зависеть друг от друга.
### Решение
Клиент и сервер сами на своей стороне шифруют данные и не обмениваются ключами (кроме авторизации).
### Последствия
Если изменится секрет на клиенте или на сервере есть риск больше не расшифровать данные.


# 007. Синхронное обновление данных
### Контекст
Если будет несколько клиентов, которые хранят оффлайн незакоммиченные данные, то обязательно возникнут конфликты.
### Решение
При каждом изменении данных клиент сразу шлет на сервер данные.
### Последствия
Если пропадет интернет, то локально измененные данные не будут обновлены.


# 008. Клиенту необходимо иметь публичный ключ для верификации JWT
### Контекст
Для того чтобы верифицировать подлинность и срок действия JWT, а также извлекать из него идентификатор пользователя, клиенту необходим публичный ключ, который может изменяться вместе с приватным ключом на сервере. Зашить в бинарник клиента его не получится, поэтому лучше запрашивать с сервера.
### Решение
В случае обновления приватного и публичного ключа на сервере, клиент просто перезапросит ключи и попросит переавторизоваться.
### Последствия
Можно без рисков обновлять ключи на сервере, однако у клиента теперь есть необходимость перезапрашивать ключ в случае неудачи. 


# 009. Все данные всех пользователей на клиенте хранятся в одном файле
### Контекст
На клиенте данные должны храниться в зашифрованном виде и нужно скрыть сколько у какого пользователя хранится определенных данных.
### Решение
Все данные всех пользователей на клиенте хранятся в одном файле.
### Последствия
Потеря одного файла ведет к риску потерять локальные данные.


# 010. Использование bboltdb в качестве хранилища клиента
### Контекст
Для хранения не хочется самим реализовывать запись в файл.
### Решение
Чтобы не реализовать самостоятельно запись файлы, можно использовать embed базу `bboltdb`.
### Последствия
Нужно записывать в файл сразу зашифрованные данные, но не шифровать файл. Это может раскрыть сколько ресурсов есть у пользователя и их идентификаторы на стороне сервера.


# 011. На сервере структура данных остается открытой, но значения шифруются
### Контекст
Мы должны хранить все данные пользователей в зашифрованном виде, но нужно оставить возможность для простой миграции данных.
### Решение
Структура данных остается открытой, шифруются только значения.
### Последствия
Если злоумышленник получит доступ к бд на сервере, ему будет проще найти интересующие его зашифрованные данные.


# 012. На клиенте данные шифруются полностью, вместе со структурой
### Контекст
Мы должны хранить все данные пользователей в зашифрованном виде, но вероятность утечки пользовательского файла крайне выше, чем на сервере.
### Решение
Данные шифруются целиком на стороне клиента логикой репозитория.
### Последствия
Если злоумышленник получит доступ к файлу с пользовательскими данными, он сможет выделить только коллекции данных и уникальные идентификаторы.


# 013. Хранение сессий на клиенте
### Контекст
Необходимо хранить текущую сессию на клиенте, чтобы не заставлять пользователя каждый раз вводить данные для авторизации, а также иметь возможность отдавать данные без подключения к интернету.
### Решение
При успешной регистрации и авторизации шифруем и сохраняем JWT и публичный ключ для верификации.
### Последствия
Может быть только одна активная сессия. При замене JWK на сервере текущая сессия остается валидной только для чтения локальных данных.


# 014. Необходимо кодогенерировать API
### Контекст
Для предоставления API пользователям, необходимо поддерживать его всегда в актуальном состоянии.
### Решение
Чтобы экономить время, лучше использовать генератор API, например `https://github.com/swaggo/swag`.
### Последствия
Документация API будет всегда актуальна.


# 015. Произвольная текстовая метаинформация
### Контекст
Необходимо предоставить возможность добавлять произвольную метаинформацию для данных.
### Решение
Чтобы разнообразить API добавляем текстовый атрибут `meta` только для сущностей логин/пароль и банковская карта.
### Последствия
Пользователи могут сохранять любое произвольное текстовое значение в атрибут `meta`.


# 016. Использование одного запроса на синхронизацию всего контента
### Контекст
Чтобы клиент синхронизировал данные с сервером можно использовать несколько асинхронных запросов для получения контента, либо один большой.
### Решение
Использовать один запрос на получение всего контента, но с использованием сжатия.
### Последствия
В случае сбоя сети необходимо будет делать большой запрос повторно.


# 017. Параллельное чтение данных из разных репозиториев в пределах одного сценария
### Контекст
Клиент для синхронизации запрашивает сразу все данные пользователя, которые можно достать из 4х разных инстансов репозитория, можно использовать параллелизм, чтобы ускорить обработку такого запроса
### Решение
Использовать горутины и пул соединений, чтобы ускорить чтение данных в данном сценарии.
### Последствия
В худшем случае данные будут получены за время последовательной обработки, но ожидается уменьшение времени выполнения запроса.


# 018. Использование паттерна Unit Of Work для обеспечения транзакционной целостности сохранения сущностей разных типов в пределах одного сценария
### Контекст
Клиент для синхронизации запрашивает сразу все данные пользователя, и их нужно сохранить в пределах одной транзакции.
### Решение
Использовать паттерн Unit Of Work, чтобы сделать операционный слой независимым от инфраструктурного, а также независимым от выбора базы данных.
### Последствия
В случае необходимости можно будет легко заменить реализацию репозитория, необходимо только сохранить сигнатуры интерфейсов при имплементации.


# 019. Использование фасадов (оъединение нескольких сценариев использования в один)
### Контекст
При большом количестве CRUD сценариев, их становится слишком много и в них становится тяжело ориентироваться.
### Решение
Использовать фасад и объединять несколько сценариев в один с возможностью вызвать вложенный сценарий.
### Последствия
Дополнительный слой абстракции немного увеличит количество сущностей, но упростит вызов бизнес логики при использовании автодописывания.